)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Calculate dynamic multipliers for all variables
multiplier_results <- all_dynamic_multipliers(
data = sample_data,
order = optimal_order,
taus = c(0.25, 0.5, 0.75),
steps = 10,
cumulative = FALSE,
impulse = FALSE,
export = FALSE
)
# Create heatmap for a specific variable
heatmap_plot <- plot_heatmap_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",  # Replace with actual variable name from your data
export = FALSE
)
# Display the heatmap
print(heatmap_plot)
## Not run:
# Generate sample data using sim_data_generate()
sample_data <- sim_data_generate(
b = c(0.5, 0.7, 0.3, 0.2),
order = c(1, 1),
size = 100,
reps = 1
)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Calculate dynamic multipliers for all variables
multiplier_results <- all_dynamic_multipliers(
data = sample_data,
order = optimal_order,
taus = c(0.25, 0.5, 0.75),
steps = 10,
cumulative = FALSE,
impulse = FALSE,
export = FALSE
)
multiplier_results
multipliers = multiplier_results
plot_variable = "x1"
export = FALSE
file = NULL
multipliers$variable
# Get unique variable names from the multipliers data
xx <- base::unique(multipliers$variable)
xx
# Validate that the specified plot_variable exists in the data
if (!(plot_variable %in% xx)){
stop("The plot_variable parameter must be one of: ",
stringr::str_c(xx, collapse = ", "), "!")
}
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau))
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable)
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) %>%  # Filter for specified variable
tidyplots::tidyplot(step, tau, color = value)
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) %>%  # Filter for specified variable
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap()
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) %>%  # Filter for specified variable
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap() %>%  # Add heatmap layer
tidyplots::adjust_colors(new_colors = tidyplots::colors_continuous_turbo) %>%  # Set color scale
tidyplots::remove_legend_title()
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) %>%  # Filter for specified variable
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap() %>%  # Add heatmap layer
tidyplots::adjust_colors(new_colors = tidyplots::colors_continuous_turbo) %>%  # Set color scale
tidyplots::remove_legend_title() %>%  # Clean up legend
tidyplots::adjust_x_axis_title("Horizon") %>%  # Set x-axis label
tidyplots::adjust_y_axis_title("Quantile")
# Create heatmap visualization using tidyplots framework
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) %>%  # Filter for specified variable
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap() %>%  # Add heatmap layer
tidyplots::adjust_colors(new_colors = tidyplots::colors_continuous_turbo) %>%  # Set color scale
tidyplots::remove_legend_title() %>%  # Clean up legend
tidyplots::adjust_x_axis_title("Horizon") %>%  # Set x-axis label
tidyplots::adjust_y_axis_title("Quantile") %>%  # Set y-axis label
tidyplots::adjust_x_axis(breaks = base::seq(0, base::max(multipliers$step), 2)) %>%  # X-axis breaks
tidyplots::adjust_y_axis(breaks = base::seq(base::min(multipliers$tau),
base::max(multipliers$tau), 0.1)) -> p  # Y-axis breaks
multipliers$step
base::max(multipliers$step)
base::min(multipliers$tau)
# Create heatmap visualization using tidyplots framework
multipliers %>%
dplyr::filter(tau != "ols") %>%  # Exclude OLS results if present
dplyr::mutate(tau = readr::parse_number(tau)) %>%  # Convert tau to numeric
dplyr::filter(variable == plot_variable) -> multipliers1   # Filter for specified variable
multipliers1 %>%
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap() %>%  # Add heatmap layer
tidyplots::adjust_colors(new_colors = tidyplots::colors_continuous_turbo) %>%  # Set color scale
tidyplots::remove_legend_title() %>%  # Clean up legend
tidyplots::adjust_x_axis_title("Horizon") %>%  # Set x-axis label
tidyplots::adjust_y_axis_title("Quantile") %>%  # Set y-axis label
tidyplots::adjust_x_axis(breaks = base::seq(0, base::max(multipliers$step), 2)) %>%  # X-axis breaks
tidyplots::adjust_y_axis(breaks = base::seq(base::min(multipliers$tau),
base::max(multipliers$tau), 0.1)) -> p  # Y-axis breaks
multipliers1 %>%
tidyplots::tidyplot(step, tau, color = value) %>%  # Create base plot
tidyplots::add_heatmap() %>%  # Add heatmap layer
tidyplots::adjust_colors(new_colors = tidyplots::colors_continuous_turbo) %>%  # Set color scale
tidyplots::remove_legend_title() %>%  # Clean up legend
tidyplots::adjust_x_axis_title("Horizon") %>%  # Set x-axis label
tidyplots::adjust_y_axis_title("Quantile") %>%  # Set y-axis label
tidyplots::adjust_x_axis(breaks = base::seq(0, base::max(multipliers1$step), 2)) %>%  # X-axis breaks
tidyplots::adjust_y_axis(breaks = base::seq(base::min(multipliers1$tau),
base::max(multipliers1$tau), 0.1)) -> p  # Y-axis breaks
p
# Create heatmap for a specific variable
heatmap_plot <- plot_heatmap_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",  # Replace with actual variable name from your data
export = FALSE
)
devtools::document()
devtools::build()
library(QARDLFlex)
help(plot_heatmap_multipliers)
## Not run:
# Generate sample data using sim_data_generate()
sample_data <- sim_data_generate(
b = c(0.5, 0.7, 0.3, 0.2),
order = c(1, 1),
size = 100,
reps = 1
)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Calculate dynamic multipliers for all variables
multiplier_results <- all_dynamic_multipliers(
data = sample_data,
order = optimal_order,
taus = c(0.25, 0.5, 0.75),
steps = 10,
cumulative = FALSE,
impulse = FALSE,
export = FALSE
)
# Create heatmap for a specific variable
heatmap_plot <- plot_heatmap_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",  # Replace with actual variable name from your data
export = FALSE
)
# Display the heatmap
print(heatmap_plot)
devtools::document()
devtools::build()
library(QARDLFlex)
help(plot_heatmap_multipliers)
## Not run:
# Generate sample data using sim_data_generate()
sample_data <- sim_data_generate(
b = c(0.5, 0.7, 0.3, 0.2),
order = c(1, 1),
size = 100,
reps = 1
)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Calculate dynamic multipliers for all variables
multiplier_results <- all_dynamic_multipliers(
data = sample_data,
order = optimal_order,
taus = c(0.25, 0.5, 0.75),
steps = 10,
cumulative = FALSE,
impulse = FALSE,
export = FALSE
)
# Create heatmap for a specific variable
heatmap_plot <- plot_heatmap_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",  # Replace with actual variable name from your data
export = FALSE
)
# Display the heatmap
print(heatmap_plot)
devtools::document()
devtools::build()
library(QARDLFlex)
help(plot_line_multipliers)
## Not run:
# Generate sample data using sim_data_generate()
sample_data <- sim_data_generate(
b = c(0.5, 0.7, 0.3, 0.2),
order = c(1, 1),
size = 100,
reps = 1
)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Calculate dynamic multipliers for all variables
multiplier_results <- all_dynamic_multipliers(
data = sample_data,
order = optimal_order,
taus = c(0.25, 0.5, 0.75),
steps = 10,
cumulative = FALSE,
impulse = FALSE,
export = FALSE
)
# Create line plot for a specific variable with multiple quantiles
line_plot <- plot_line_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",  # Replace with actual variable name from your data
plot_taus = c(0.25, 0.5, 0.75),
export = FALSE
)
# Display the plot
print(line_plot)
# Example with single quantile (legend automatically removed)
single_quantile_plot <- plot_line_multipliers(
multipliers = multiplier_results,
plot_variable = "x1",
plot_taus = 0.5,
export = FALSE
)
print(single_quantile_plot)
devtools::document()
devtools::build()
rm(list = ls())
gc()
options(warn = -1)
Sys.setlocale("LC_TIME", "English")
library(QARDLFlex)
# 数据
data <- import("example_data.xlsx", as = "tibble")
library(bruceR)
library(tidyverse)
# 数据
data <- import("example_data.xlsx", as = "tibble")
data %>% select(date, VIX:gold) -> data
data %>% mutate(date = ymd(date)) -> data
check_data(data) # 检查数据是否符合要求
# 参数
taus <- seq(0.1, 0.9, 0.1) # 设定待估计的模型分位点
test_taus <- taus[c(1,5,9)] # 设定拟检验的分位点（需要是taus的子集）
criterion <- "AIC" # 设定最佳滞后阶数计算准则
auto_lag <- T # 是（TRUE）否（FALSE）基于信息准则选择最佳滞后期
lags <- c(1,1,1,1) # 若auto_lag为FALSE，则使用使用该手动设定的滞后期
boots <- 1000 # 分位数回归参数估计自助法重抽样次数
scale <- F # 是（TRUE）否（FALSE）对数据进行标准化处理
steps <- 20 # 动态乘数预测步长
# 创建结果存放目录
if (dir.exists("results")){
unlink("results", recursive = T)
}
dir.create("results")
# 基本描述性统计
basic_statistic <- summary_statistics(
data = data,
export = T,
file = "results/表01-基本描述性统计.xlsx"
)
basic_statistic
# 单位根检验
ur.result <- unitroot_test(data = data,
export = TRUE,
file = "results/表02-单位根检验.xlsx")
ur.result
# 数据标准化
data %>% data_scale(scale = scale) -> data
# 寻找最佳滞后期
order <- order_find(data = data,
selection = criterion,
auto_lag = auto_lag,
lags = lags,
export = TRUE,
file = "results/表03-模型滞后阶数.xlsx")
# 边界协整检验
bound_test(data = data,
order = order,
export = TRUE,
file = "results/表04-边界协整F检验.xlsx")
# ARDL估计（演示）
ardl_results <- ardl_estimate(data = data, order = order)
ardl_results$ARDL_coefficient
ardl_results$ECM_coefficient
# 单一分位点的QARDL估计（演示）
qardl_results <- qardl_estimate(data = data,
order = order,
tau = 0.5,
boots = boots)
boots <- 100 # 分位数回归参数估计自助法重抽样次数
# 单一分位点的QARDL估计（演示）
qardl_results <- qardl_estimate(data = data,
order = order,
tau = 0.5,
boots = boots)
qardl_results$QARDL_coefficient
qardl_results$QECM_coefficient
qardl_results$QARDL_coef
qardl_results$QECM_coef
# 多个分位点的QARDL估计（导出OLS和所有分位点结果）
estimation <- coef_estimate(data = data,
order = order,
taus = taus,
boots = boots,
export = TRUE,
file_ardl = "results/表05-QARDL估计结果（ARDL形态）.xlsx",
file_ecm = "results/表06-QARDL估计结果（ECM形态）.xlsx")
# 绘制系数图
plot_coef <- plot_ECM(
estimation,
order,
plot_term = "long",
variable = "VIX",
taus,
ci = T,
level = 0.9,
export = F)
# （演示）批量绘制所有系数图
x1 <- c("VIX", "bitcoin", "bitcoin", "GreenBond", "GreenBond", "gold")
x2 <- c("long", "long", "short", "long", "short", "long")
x3 <- c("ECM", "长期", "短期", "长期", "短期", "当期")
x3 <- str_c("results/图01-", x1, "-", x3, "系数走势.png")
plot_coefs <- list(x1, x2, x3) %>%
pmap(function(x1, x2, x3){
plot_ECM(
estimation,
order,
plot_term = x2,
variable = x1,
taus,
ci = T,
level = 0.9,
export = T,
file = x3)
})
# （演示）检验给定不同分位点（两个或多个均可）ECM模型中的系数是否相等
cross_quantile_test(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
test_taus = taus[c(1,5,9)],
variable = c("bitcoin"),
term = "short",
joint = F # 不同滞后期短期系数是否加总后再检验
)
# 所有单变量长短期系数跨指定分位数相等性Wald检验
cross_single <- single_variable_cross_wald(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
test_taus = test_taus,
export = T,
file = "results/表07a-单变量跨指定分位数Wald检验.xlsx"
)
combn(taus, 2) %>% as_tibble() %>% as.list() %>%
map_dfr(~ single_variable_cross_wald(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
test_taus = .,
export = F
)) %>%
export("results/表07b-单变量跨所有分位数（两个）Wald检验.xlsx")
combn(taus, 3) %>% as_tibble() %>% as.list() %>%
map_dfr(~ single_variable_cross_wald(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
test_taus = .,
export = F
)) %>%
export("results/表07c-单变量跨所有分位数（三个）Wald检验.xlsx")
# 指定几个变量的分位数内系数相等性检验
within_wald <- within_quantile_test(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
variables = c("bitcoin", "GreenBond"),
export = T,
file = "results/表08-多变量分位数内Wald检验.xlsx"
)
within_wald
# 所有可能的双变量分位数内检验结果（演示）
order[-1][order[-1] > 0] %>% names() %>%
combn(2) %>%
as_tibble() %>%
as.list() %>%
map_dfr(
~ within_quantile_test(
estimation = estimation,
order = order,
boots = boots,
taus = taus,
variables = .,
export = F
)
)
# 计算动态乘数（包括OLS和分位数回归）
multipliers <- all_dynamic_multipliers(
data = data,
order = order,
taus = taus,
steps = steps,
cmulative = FALSE,
impulse = FALSE,
export = TRUE,
file = "results/表09-动态乘数计算结果.xlsx"
)
all_dynamic_multipliers
# 计算动态乘数（包括OLS和分位数回归）
multipliers <- all_dynamic_multipliers(
data = data,
order = order,
taus = taus,
steps = steps,
cumulative = FALSE,
impulse = FALSE,
export = TRUE,
file = "results/表09-动态乘数计算结果.xlsx"
)
multipliers
# 绘制动态乘数折线图
plot_line_multipliers(multipliers,
plot_variable = c("bitcoin"),
plot_taus = c(0.2, 0.5, 0.8),
export = FALSE,
file = NULL)
# 绘制动态乘数热图
plot_heatmap_multipliers(multipliers,
plot_variable = c("bitcoin"),
export = FALSE,
file = NULL)
help("tidyverse")
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
library(QARDLFlex)
devtools::document()
devtools::build()
devtools::install_github("Passenger53/QARDLFlex")
devtools::document()
devtools::build()
devtools::install_github("Passenger53/QARDLFlex")
remove.packages("QARDLFlex")
devtools::install_github("Passenger53/QARDLFlex")
devtools::install_github("Passenger53/QARDLFlex")
devtools::document()
devtools::build()
library(QARDLFlex)
help(generate_cumulative_shocks)
## Not run:
# Generate sample data using sim_data_generate()
sample_data <- sim_data_generate(
b = c(0.5, 0.7, 0.3, 0.2),
order = c(1, 1),
size = 100,
reps = 1
)[[1]]
# Find optimal lag order using order_find()
optimal_order <- order_find(sample_data, selection = "BIC", export = FALSE)
# Generate cumulative shocks for specific variables
processed_data <- generate_cumulative_shocks(
variable_names = c("x1", "x2"),  # Replace with actual variable names
data = sample_data
)
# Generate cumulative shocks for specific variables
processed_data <- generate_cumulative_shocks(
variable_names = "x1",  # Replace with actual variable names
data = sample_data
)
View(processed_data)
# View the modified data structure
str(processed_data)
devtools::install_github("Passenger53/QARDLFlex")
rm(list = ls())
gc()
options(warn = -1)
Sys.setlocale("LC_TIME", "English")
library(QARDLFlex)
library(bruceR)
library(tidyverse)
# 数据
data <- import("example_data.xlsx", as = "tibble")
